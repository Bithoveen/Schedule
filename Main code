//Вступление:
//Данный программный продукт предназначен для генерации табелей Ф1.
//Он генерирует графики для сотрудников на месяц, учитывая такие правила:
//1)	Зависимость нового графика от графика предыдущего месяца
//2)	Чередование выходных и рабочих (перед или после 5 рабочих 2 или 3 выходных, после 4 рабочих 1, 2 или 3 выходных)
//3)	Выполнение нормы часов за месяц, в том числе при отпуске
//4)	Выполнение нормы часов за авансовый период (первые 15 дней), в том числе при отпуске
//5)	Равномерность распределения сотрудников по сменах (как минимум 1 человек на смену, приблизительно одинаковое количество сотрудников на каждую смену)
//6)	Плавность перехода между сменами (избегать резких переходов со смены на смену в течении рабочей недели (например, вв1111вв – хорошо, вв11222вв – плохо) )
//Осталось пару вещей, которые я не проработал, т.к. не знал, какие будут входные данные:
//7)	Сокращенные дни перед праздниками
//8)	Проставить часы (мое ПО выдает только рабочие дни со сменой и выходные, не проставляя часы)
//Входные данные:
//Otp – матрица отпусков. Первые 2 столбца – ФИО и должность сотрудника, остальные столбцы - матрица с отмеченными пропусками
//Cs – матрица прошлого месяца, где первые 2 столбца - ФИО и должность сотрудника, остальные 5 – отмеченные 5 последних дня предыдущего месяца.
//w  – массив календарных дней на месяц (выходные и рабочие)
//На выходе таблица со списком сотрудников и составленная матрица расписаний, где 2 – вторая смена, 1 – первая смена, 0 – выходной, другое (Д/О/Б/.. – в зависимости от того, что ввел пользователь).

//Функции button1_Click, button2_Click, button3_Click необходимы были чисто для интерфейса при разработке 
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;

namespace Табель
{
    public partial class Prev : Form
    {
        public int N = 3; //К-во сотрудников
        public string[,] B0 = new string[3, 7];
        public string[,] Otp = new string[3, 7];
        public string[,] Cs = new string[3, 7];
        public int[] w = { 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1 };

        public Prev()
        {
            InitializeComponent();
            dataGridView1.Rows.Add();
            this.dataGridView1.Rows[0].Cells[0].Value = "ФИО";
            this.dataGridView1.Rows[0].Cells[1].Value = "Должность";
            this.dataGridView1.Rows[0].Cells[2].Value = "-5";
            this.dataGridView1.Rows[0].Cells[3].Value = "-4";
            this.dataGridView1.Rows[0].Cells[4].Value = "-3";
            this.dataGridView1.Rows[0].Cells[5].Value = "-2";
            this.dataGridView1.Rows[0].Cells[6].Value = "-1";
        }

        public string[,] grap(string[,] A, string[,] C, int[] w)
        {
            // w - матрица календарных дней
            //h1 - к-во выходных в 1-й половние   h2 - к-во выходных общее   mc -к-во дней в месяце
            // A - матрица отпусков, С -  матрица предыдущего месяца

            int h1 = 0, h2 = 0, mc = w.Length;
            // Считаем к-во выходных в первые 15 дней
            for (int i = 0; i < w.Length; i++)
            {
                if (w[i] == 0)
                {
                    h2++;
                    if (i < 15)
                        h1++;
                }
            }
            // ======================

            int[] wnd15 = new int[N];
            int[] wkd15 = new int[N];
            int[] wnd = new int[N];
            int[] wkd = new int[N];
            int[] wnd15ch = new int[N];
            int[] wkd15ch = new int[N];
            int[] wndch = new int[N];
            int[] wkdch = new int[N];
            string[,] As = new string[N, w.Length + 2];
            string[,] AC = new string[N, w.Length + 5];
            string[,] D = Matrix();
            // As - матрица, где сохраняются значения отсутствия (О,Д,..) 
            // D - матрица с наборами графиков (функция описанна в определении)
            // AC - матрица где мы сохраняем отпуска
            //wkd - к-во выходных в период отсутствия, когда выходной был во время рабочего
            //wnd - к-во рабочих в период отсутствия, когда рабочий был во время выходного
            //wkd15 wnd15  - тоже самое для первой половины месяца
            //wkdch - к-во выходных в период отсутствия, когда выходной был во время рабочего для графика, который рассматривается как кандидат
            //wndch - к-во рабочих в период отсутствия, когда рабочий был во время выходного для графика, который рассматривается как кандидат
            //wkd15ch wnd15ch  - тоже самое для первой половины месяца

            #region

            for (int i = 0; i < A.GetLength(0); i++)
                for (int j = 0; j < A.GetLength(1); j++)                
                    As[i, j] = A[i, j];


            //Если у работника отсутствие и в этот день выходной, то увеличиваем wkd15[i], если в этот день рабочий, то увеличиваем wnd15[i]
            //Это необходимо потому, что при отсутствии у нас меняется к-во выходных и/или рабочих. К примеру, если у рабочего отпуск 1 и 2 августа, то общее количество выходных будет 9 вместо 11
            //Сначала для авансового периода
            for (int i = 0; i < A.GetLength(0); i++)
            {
                for (int j = 2; j < 17; j++)
                    if (A[i, j] != "0")
                    {
                        if ((w[j - 2] == 0))
                            wkd15[i]++;
                        if ((w[j - 2] != 0))
                            wnd15[i]++;
                    }
            }
            //Затем для полного месяца. Выставляем дни отсутствий ("-1")
            for (int i = 0; i < A.GetLength(0); i++)
                for (int j = 2; j < A.GetLength(1); j++)
                    if (A[i, j] != "0")
                    {
                        if ((w[j - 2] == 0))
                            wkd[i]++;
                        if ((w[j - 2] != 0))
                            wnd[i]++;
                        A[i, j] = "-1";
                    }
            //========================
            #endregion
            // Последующая идея состоит в то, что мы из массива возможных графиков выбираем максимальн допустимые
            // Для начала мы отбираем те, у которых выполняется норма за месяц. Отбираем, значит запоминаем индекс (ind) из массива допустимых графиков (D)
            int[,] hnm = new int[N, 15000]; //норма часов за месяц (тут и дальше - массивы индексов)
            //Дальше Отбираем уже их массива допустимых по норме часов за месяц допустимые по норме часов за авансовый период. Также запоминаем индексы.
            int[,] hnhm = new int[N, 15000];//норма часов за полмесяца
            int ind = 1, norm1 = 0, norm2 = 0; //norm1 - к-во допустимых графиков для hnm, norm2 - к-во допустимых графиков для hnhm

            //Тут проходит процедура, которая учитывает предыдущий месяц. Например, если у нас в предыдущем месяце последние 5 дней были рабочие (11111),
            //то мы можем подставить только график вида 1111100....
            //Подставляем мы графики не напрямую с первого числа, а с возможным пересечением. Т.е., если у нас были последние 5 дней рабочик, то
            //мы начиаем подставлять график вида 1111100.... с 5 с конца дня предыдущего месяца (если 31 день, то с 27-го)
            //С какого именно дня начинаем начинаем, нам говорит индекс razn. Например, для 11111 разница 3. Учитывая, что 2 первых столбца фио и должность, то начинаем с -(2+3) = -5 дня.
            // Другой случай, 11001. Здесь мы начинаем отчет с последнего дня (razn = -1). Т.е. новый график может быть вида 111100..., и тогда ми имеем 1100|111100. Т.е. мы начинаем отчет с последнего выходного предудыщего месяца.
            //Не все графики подходят под предыдущий месяц. Например, если у нас последние дни были вида 11011, то новый может начинается только с 4 рабочих дней, т.к. перед 5 рабочими не может быть 1 выходной
            //Для этого мы вводим переменную s45, которая говорит там, как может начинатся график (с 5 или с 4 рабочих дней)
            //В D[ind, 1] записывается, какого вида график ("4" - рабочие первые 4 дня, "5" - рабочие первые 5 дней) 
            for (int i = 0; i < N; i++)
            {
                int razn = 0;
                string s45 = "4";
                if ((C[i, 2] == "0") && (C[i, 3] == "1") && (C[i, 4] == "1") && (C[i, 5] == "1") && (C[i, 6] == "1"))
                { razn = 2; s45 = "4"; }
                if ((C[i, 2] == "1") && (C[i, 3] == "0") && (C[i, 4] == "1"))
                { razn = 1; s45 = "4";}
                if ((C[i, 3] == "1") && (C[i, 4] == "0") && (C[i, 5] == "1"))
                { razn = 0; s45 = "4";}
                if ((C[i, 4] == "1") && (C[i, 5] == "0") && (C[i, 6] == "1"))
                { razn = -1; s45 = "4";}
                if ((C[i, 5] == "1") && (C[i, 6] == "0"))
                { razn = -2; s45 = "4";}
                if ((C[i, 2] == "0") && (C[i, 3] == "0") && (C[i, 4] == "1"))
                { razn = 1; s45 = "0"; }
                if ((C[i, 3] == "0") && (C[i, 4] == "0") && (C[i, 5] == "1"))
                { razn = 0; s45 = "0"; }
                if ((C[i, 4] == "0") && (C[i, 5] == "0") && (C[i, 6] == "1"))
                { razn = -1; s45 = "0"; }
                if ((C[i, 5] == "0") && (C[i, 6] == "0"))
                { razn = -2; s45 = "0"; }
                if ((C[i, 2] == "1") && (C[i, 3] == "1") && (C[i, 4] == "1") && (C[i, 5] == "1") && (C[i, 6] == "1"))
                { razn = 3; s45 = "5";}

                #region
                norm1 = 0; norm2 = 0; ind = 1;
                while (ind < 9450)
                {
                    if (((D[ind, 1] == s45) && (s45 != "0")) || (s45 == "0"))
                    {
                        wkdch[i] = 0;
                        wndch[i] = 0;
                        for (int t = 2; t < A.GetLength(1); t++)
                        {
                            if (A[i, t] != "-1")
                            {
                                if (D[ind, 0][t + razn].ToString() == "0")
                                    wkdch[i]++;
                                if (D[ind, 0][t + razn].ToString() == "1")
                                    wndch[i]++;
                            }
                        }
                        //Проверяем, сходятся ли рабочие и выходние, учитывая отсутствие, с нормой.
                        if ((wkdch[i] + wkd[i] == h2) && (wndch[i] + wnd[i] == mc - h2))
                        {
                            hnm[i, norm1] = ind;
                            norm1++;
                        }
                    }
                    ind++;
                }
                ind = 1;
                for (int j = 0; j < norm1; j++)
                {
                    wkd15ch[i] = 0;
                    wnd15ch[i] = 0;
                    for (int t = 2; t < 17; t++)
                    {
                        if (A[i, t] != "-1")
                        {
                            if (D[hnm[i, j], 0][t + razn].ToString() == "0")
                                wkd15ch[i]++;
                            if (D[hnm[i, j], 0][t + razn].ToString() == "1")
                                wnd15ch[i]++;
                        }
                    }
                    if ((wkd15ch[i] + wkd15[i] == h1) && (wnd15ch[i] + wnd15[i] == 15 - h1))
                    {
                        hnhm[i, norm2] = hnm[i, j];
                        norm2++;
                    }
                }

                if (norm2 == 0)
                {
                    for (int j = 0; j < norm1; j++)
                        hnhm[i, j] = hnm[i, j];
                    norm2 = norm1;
                }
                //Здесь мы будем искать графики, которые вместе с уже построенными остальными графиками даст наилучший результат по равномерному распределению сотрудников по сменам.
                //Т.е. мы действуем по принципу Беллмана, мы создаем первый график независимо от других, второй график строим уже так, чтобы было как можно меньше выходных в один день с первым сотрудником, и так далее
                //При этом мы выбираем из вариантов, отобранных выше, т.е. чтобы выполнялись нормы по часам.
                //Для реализации мы по каждому столбцу считаем общее к-во рабочих всем графикам предыдущих работников и теперешним графиком-кандидатом
                //Далее мы прибавляем те суммы столбцов (sumrez), где к-во рабочих дней по столбцу меньше половины. И потом ищем минимум по  sumrez среди всех вариантов.
                double sum = 0.5, sumrez = 1, max = 1;
                int maxidx = 1;
                if (i > 0)
                    for (int l = 0; l < norm2; l++)
                    {

                        for (int t = 2; t < A.GetLength(1); t++)
                        {
                            sum = 0;
                            for (int k = i - 1; k >= 0; k--)
                            {
                                if (A[k , t] == "1")
                                    sum += 1;
                            }
                            sum += Convert.ToInt16(D[hnhm[i, l], 0][t + razn].ToString());
                            if (sum <= (i+1) / 2)
                                sumrez += sum;
                        }
                        if (l == 0)
                            max = sumrez;
                        else
                            if (sumrez > max)
                            {
                                maxidx = l;
                                max = sumrez;
                            }
                        sumrez = 1;
                    }
                for (int t = 2; t < A.GetLength(1); t++)
                    if (A[i, t] != "-1")
                        A[i, t] = D[hnhm[i, maxidx], 0][t + razn].ToString();
                    else
                        A[i, t] = "-1";
                #endregion

            }
            //Заполняем смены (подробнее в опиределении функции)
            A = Smena(A);

            //возвращем готовые графики, переносим вместо -1 значения отсутствий
            for (int t = 2; t < A.GetLength(1); t++)
                for (int i = 0; i < A.GetLength(0); i++)
                if (A[i, t] == "-1")                    
                    A[i, t] = As[i,t];

            return A;
        }

        private void button1_Click(object sender, EventArgs e)
        {
            Table(B0, N);
        }

        private void button2_Click(object sender, EventArgs e)
        {
            string[,] B = new string[B0.GetLength(0),B0.GetLength(1)];
            B0 = Cs;
            string[,] Otp1 = new string[Otp.GetLength(0), Otp.GetLength(1)];
            for (int i = 0; i < Otp.GetLength(0); i++)
                for (int j = 0; j < Otp.GetLength(1); j++)
                    Otp1[i, j] = Otp[i, j];
            B0 = grap(Otp1,Cs,w);
        }
        
        public static string[,] Smena(string[,] A)
        {
            //Общий смысл этой функции в том, что мы расставляем вместо единичек смены - 1 или 2.
            //Для этого мы вместо 1 ставим смену на первые дни так, чтобы она была инверсной (инверсная 1 - 2, и наоборот) смены в этот же день предыдущего сотрудник, чтобы выполнялось условие равномерного расспределения по сменам
          
            int k = 0, i = 0, j = 0, t = 0;
            string[,] An = new string[A.GetLength(0),A.GetLength(1)];
            string[,] As = new string[A.GetLength(0), A.GetLength(1)];

            for(i = 0; i<A.GetLength(0); i++)
                for (j = 0; j < A.GetLength(1); j++)               
                    An[i, j] = A[i, j];
            //Ставим смены для первого работника
            i = 0;
            for (j = 2; j < A.GetLength(1); j++)
            {
                if ((A[i, j - 1] == "0") && (A[i, j] != "0"))
                    k++;
                if (A[i, j] != "0")
                    An[i, j] = (k % 2 + 1).ToString();//чтобы у работника были разные смены, и при переходы были более-менее равномерные, смена меняется после каждого выходного. k % 2 + 1 - номер смены
            }
            
            //Ставим смены для остальных работников
            for (i = 1; i < A.GetLength(0); i++)  
            {
                t = 2;
                while (Convert.ToInt16(A[i, t]) * Convert.ToInt16(An[i - 1, t]) == 0)//ищем, когда у текущего и предыдущего сотрудника не будет в один день рабочий
                    t++;
                k = Convert.ToInt16(An[i - 1, k]) % 2;
                //Может быть вариант, что для первого рабочего график имеет вид 1111100
                // а для второго                                                1011111
                //Поэтому мы начинам отчет инверсии с 5-го элемента, т.е. у нас будет не 1111100 а 1111100   - это обеспечит равномерность
                //                                                                       2011111,  1022222
                for (j = 2; j < A.GetLength(1); j++)
                {
                    if ((A[i, j - 1] == "0") && (A[i, j] != "0") && (j > 5))
                        k++;
                    if (A[i, j] != "0")
                        An[i, j] = (k % 2 + 1).ToString();
                }
                    }


            //Все же, при таком алгоримте могут иногда возникать ситуации, когда для одного дня работников на одну смену может быть намного больше, чем на другую.
            //Поэтому мы контролируем, если какой-то смены больше другой более чем на две, то меняем текущую смену на инверсную
            int one = 0, two = 0;
            for (i = 0; i < An.GetLength(0); i++)
                for (j = 2; j < An.GetLength(1); j++)
                {
                    one = 0;
                    two = 0;
                    if (An[i, j] != "0")
                    {
                        for (k = i; k < An.GetLength(0) + i; k++)
                        {
                            if (An[k % An.GetLength(0), j] == "1")
                                one++;
                            if (An[k % An.GetLength(0), j] == "2")
                                two++;
                        }
                        if (one - two >= 2)
                            An[i, j] = "2";
                        if (two - one >= 2)
                            An[i, j] = "1";
                    }
            }

            for (i = 0; i < A.GetLength(0); i++)
                for (j = 0; j < A.GetLength(1); j++)
                    if(A[i,j]!="1")
                    An[i, j] = A[i, j];

            return An;
        }
           
        public string[,] Matrix()
        {
   
            string[] S = {
                             "1111100",
                             "111100",
                             "11110",
                             "11111000",
                             "1111000"
                         }; //Из этих "кусков" можно составить любой график
            string[,] Cn = new string [9500,2];
            char[, ,] D = new char[9500, 36, 2];
            int cou = 0;
            for (int i1 = 0; i1 <= 4; i1++)
                for (int i2 = 0; i2 <= 4; i2++)
                    for (int i3 = 0; i3 <= 4; i3++)
                        for (int i4 = 0; i4 <= 4; i4++)
                            for (int i5 = 0; i5 <= 4; i5++)
                                for (int i6 = 0; i6 <= 4; i6++)
                                    if (S[i1].Length + S[i2].Length + S[i3].Length + S[i4].Length + S[i5].Length + S[i6].Length >= 36)//учитывая 5 дней предыдущего месяца и максимум 31 теперешнего, минимум нам нужна длина в 36 символов
                                        if (!(
                                            (((i2 == 0) || (i2 == 3)) && (i1 == 2)) ||
                                            (((i3 == 0) || (i3 == 3)) && (i2 == 2)) ||
                                            (((i4 == 0) || (i4 == 3)) && (i3 == 2)) ||
                                            (((i5 == 0) || (i5 == 3)) && (i4 == 2)) ||
                                            (((i6 == 0) || (i6 == 3)) && (i5 == 2))
                                            ))//Отдельно пришлось прописать, чтобы после 11110 не было графика, где 5 рабочих
                                        {
                                            cou++;
                                            Cn[cou, 0] = S[i1] + S[i2] + S[i3] + S[i4] + S[i5] + S[i6];
                                            if ((i1 == 1) || (i1 == 2) || (i1 == 4))
                                                Cn[cou, 1] = "4";//Начинается с 4 рабочих
                                            else
                                                Cn[cou, 1] = "5";//Начинается с 5 рабочих
                                            for (int i = 0; i < 36; i++)
                                            {
                                                for (int j = 0; j < 2; j++)
                                                    D[cou, i, 0] = Cn[cou, 0][i];
                                                D[cou, 0, 1] = Cn[cou, 1][0];
                                            }


                                }
            return Cn;
    }

        public void Table(string[,] B, int N)
        {
            int n1 = N, n = 33;
            int j = 0;
            double[,] A = new double[n, n1];
            double[] b = new double[n1];
            DataGridViewCellStyle highlightCellStyle = new DataGridViewCellStyle();
            highlightCellStyle.BackColor = Color.Aqua;
            dataGridView2.Rows.Add();
            dataGridView2.Rows.Add();
            dataGridView2.Rows.Add();
            dataGridView2.Rows.Add();
            dataGridView2.Rows.Add();
            dataGridView2.Rows.Add();
            dataGridView2.Rows.Add();
            dataGridView2.Rows.Add();

            this.dataGridView2.Rows[0].Cells[2].Value = "Дата";
            this.dataGridView2.Rows[1].Cells[0].Value = "ФИО";
            this.dataGridView2.Rows[1].Cells[1].Value = "Должность";
            for (int i = 1; i < 32; i++)
            {
                this.dataGridView2.Rows[1].Cells[i + 1].Value = i;
            }
            this.dataGridView2.Rows[0].DefaultCellStyle = highlightCellStyle;
            dataGridView2.Rows.Add();
            dataGridView2.Rows.Add();
            dataGridView2.Rows.Add();

            for (int i = 2; i < n1+2; i++)
            {
                for (j = 0; j < n; j++)
                {
                    this.dataGridView2.Rows[i].Cells[j ].Value = B[i -2 , j];
                }
            }
        }       

        private void button3_Click_1(object sender, EventArgs e)
        {
            string[,] A = new string[N, 33];
          
            for (int i = 0; i < A.GetLength(0); i++)
                for (int j = 0; j < A.GetLength(1); j++)
                {
                    A[i, j] =B0[i,j];
                    }

            dataGridView1.Rows.Add();
            for (int i = 2; i < N + 2; i++)
                for (int j = 0; j < 7; j++)
                {

                    dataGridView1.Rows.Add();
                    this.dataGridView1.Rows[i].Cells[j].Value = Cs[i - 2, j];
                }
                    
            for (int i = 2; i < N + 2; i++)
                for (int j = 0; j < 33; j++)
                    this.dataGridView2.Rows[i].Cells[j].Value = A[i -2 , j];
        }

    }
}


